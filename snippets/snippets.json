{
  "gql-simple-storage-getData-recipe-schema": "query GetData($address: String!) {\n  getData(\n    address: $address\n    connection: {\n      networkNameOrChainId: $network\n    }\n  )\n}",
  "gql-simple-storage-setIpfsData-recipe-schema": "mutation {\n  setIpfsData(\n    options: {\n      address: $address\n      data: $data\n    }\n    connection: {\n      networkNameOrChainId: $network\n    }\n  ) {\n    ipfsHash\n    txReceipt\n  }\n}",
  "js-e2e-test-build": "// highlight-start\nimport { buildAndDeployApi, initTestEnvironment, stopTestEnvironment } from \"@web3api/test-env-js\";\nimport path from \"path\";\n// highlight-end\n\njest.setTimeout(120000);\n\ndescribe('Wrapper Test', () => {\n\n  // highlight-start\n  // the ENS URI that will be used to query  the wrapper\n  let ensUri: string;\n  // highlight-end\n\n  beforeAll(async () => {\n    // initialize test environment\n    const { ipfs, ethereum, ensAddress, registrarAddress, resolverAddress } = await initTestEnvironment();\n\n    // highlight-start\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + \"/../../../\"); // absolute path to directory with web3api.yaml\n    const api = await buildAndDeployApi({\n      apiAbsPath: apiPath,\n      ipfsProvider: ipfs,\n      ensRegistryAddress: ensAddress,\n      ethereumProvider: ethereum,\n      ensRegistrarAddress: registrarAddress,\n      ensResolverAddress: resolverAddress,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network \"testnet\"\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test(\"\", async () => { });\n});",
  "js-e2e-test-config": "// highlight-start\nimport { ClientConfig, Web3ApiClient } from \"@web3api/client-js\";\nimport { ethereumPlugin, EthereumPluginConfigs } from \"@web3api/ethereum-plugin-js\";\nimport { ipfsPlugin, IpfsPluginConfigs } from \"@web3api/ipfs-plugin-js\";\nimport { ensPlugin, EnsPluginConfigs } from \"@web3api/ens-plugin-js\";\n// highlight-end\nimport { buildAndDeployApi, initTestEnvironment, stopTestEnvironment } from \"@web3api/test-env-js\";\nimport path from \"path\";\n\njest.setTimeout(120000);\n\ndescribe('Wrapper Test', () => {\n\n  // the ENS URI that will be used to query  the wrapper\n  let ensUri: string;\n\n  // highlight-start\n  // an instance of the Polywrap Client\n  let client: Web3ApiClient;\n  // highlight-end\n\n  beforeAll(async () => {\n    // initialize test environment\n    const { ipfs, ethereum, ensAddress, registrarAddress, resolverAddress } = await initTestEnvironment();\n\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + \"/../../../\"); // absolute path to directory with web3api.yaml\n    const api = await buildAndDeployApi({\n      apiAbsPath: apiPath,\n      ipfsProvider: ipfs,\n      ensRegistryAddress: ensAddress,\n      ethereumProvider: ethereum,\n      ensRegistrarAddress: registrarAddress,\n      ensResolverAddress: resolverAddress,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network \"testnet\"\n\n    // highlight-start\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfigs = {\n      provider: ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfigs = {\n      networks: {\n        testnet: {\n          provider: ethereum, // Ganache test network\n        },\n        mainnet: {\n          provider: \"http://localhost:8546\", // Ganache Ethereum mainnet fork\n        },\n      },\n      defaultNetwork: \"testnet\",\n    };\n\n    // configure the ens plugin\n    const ensConfig: EnsPluginConfigs = {\n      query: {\n        addresses: {\n          testnet: ensAddress,\n        },\n      },\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: \"w3://ens/ipfs.web3api.eth\",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: \"w3://ens/ens.web3api.eth\",\n          plugin: ensPlugin(ensConfig),\n        },\n        {\n          uri: \"w3://ens/ethereum.web3api.eth\",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new Web3ApiClient(clientConfig);\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test(\"\", async () => { });\n});",
  "js-e2e-test-deploy": "import { ClientConfig, Web3ApiClient } from \"@web3api/client-js\";\nimport { ethereumPlugin, EthereumPluginConfigs } from \"@web3api/ethereum-plugin-js\";\nimport { ipfsPlugin, IpfsPluginConfigs } from \"@web3api/ipfs-plugin-js\";\nimport { ensPlugin, EnsPluginConfigs } from \"@web3api/ens-plugin-js\";\nimport { buildAndDeployApi, initTestEnvironment, stopTestEnvironment } from \"@web3api/test-env-js\";\nimport path from \"path\";\n\njest.setTimeout(120000);\n\ndescribe('Wrapper Test', () => {\n\n  // the Ethereum address of the SimpleStorage smart contract\n  // highlight-start\n  let simpleStorageAddress: string;\n  // highlight-end\n\n  // the ENS URI that will be used to query  the wrapper\n  let ensUri: string;\n\n  // an instance of the Polywrap Client\n  let client: Web3ApiClient;\n\n  beforeAll(async () => {\n    // initialize test environment\n    const { ipfs, ethereum, ensAddress, registrarAddress, resolverAddress } = await initTestEnvironment();\n\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + \"/../../../\"); // absolute path to directory with web3api.yaml\n    const api = await buildAndDeployApi({\n      apiAbsPath: apiPath,\n      ipfsProvider: ipfs,\n      ensRegistryAddress: ensAddress,\n      ethereumProvider: ethereum,\n      ensRegistrarAddress: registrarAddress,\n      ensResolverAddress: resolverAddress,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network \"testnet\"\n\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfigs = {\n      provider: ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfigs = {\n      networks: {\n        testnet: {\n          provider: ethereum, // Ganache test network\n        },\n        mainnet: {\n          provider: \"http://localhost:8546\", // Ganache Ethereum mainnet fork\n        },\n      },\n      defaultNetwork: \"testnet\",\n    };\n\n    // configure the ens plugin\n    const ensConfig: EnsPluginConfigs = {\n      query: {\n        addresses: {\n          testnet: ensAddress,\n        },\n      },\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: \"w3://ens/ipfs.web3api.eth\",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: \"w3://ens/ens.web3api.eth\",\n          plugin: ensPlugin(ensConfig),\n        },\n        {\n          uri: \"w3://ens/ethereum.web3api.eth\",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new Web3ApiClient(clientConfig);\n\n    // deploy simple storage contract\n    // highlight-start\n    const { data, error } = await client.invoke<string>({\n      uri: ensUri,\n      module: \"mutation\",\n      method: \"deployContract\",\n    });\n    if (error) throw error;\n    simpleStorageAddress = data as string;\n    // highlight-end\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test(\"\", async () => { });\n});",
  "js-e2e-test-final": "import { ClientConfig, Web3ApiClient } from \"@web3api/client-js\";\nimport { ethereumPlugin, EthereumPluginConfigs } from \"@web3api/ethereum-plugin-js\";\nimport { ipfsPlugin, IpfsPluginConfigs } from \"@web3api/ipfs-plugin-js\";\nimport { ensPlugin, EnsPluginConfigs } from \"@web3api/ens-plugin-js\";\nimport { buildAndDeployApi, initTestEnvironment, stopTestEnvironment } from '@web3api/test-env-js';\nimport path from \"path\";\n// highlight-next-line\nimport { SetIpfsDataResult } from '../types/w3';\n\njest.setTimeout(120000);\n\ndescribe('Wrapper Test', () => {\n\n  // the Ethereum address of the SimpleStorage smart contract\n  let simpleStorageAddress: string;\n\n  // the ENS URI that will be used to query  the wrapper\n  let ensUri: string;\n\n  // an instance of the Polywrap Client\n  let client: Web3ApiClient;\n\n  beforeAll(async () => {\n    // initialize test environment\n    const { ipfs, ethereum, ensAddress, registrarAddress, resolverAddress } = await initTestEnvironment();\n\n    // deploy api\n    const apiPath: string = path.resolve(__dirname + \"/../../../\"); // absolute path to directory with web3api.yaml\n    const api = await buildAndDeployApi({\n      apiAbsPath: apiPath,\n      ipfsProvider: ipfs,\n      ensRegistryAddress: ensAddress,\n      ethereumProvider: ethereum,\n      ensRegistrarAddress: registrarAddress,\n      ensResolverAddress: resolverAddress,\n    });\n    ensUri = `ens/testnet/${api.ensDomain}`; // we will call our Ethereum test network \"testnet\"\n\n    // configure the ipfs plugin\n    const ipfsConfig: IpfsPluginConfigs = {\n      provider: ipfs,\n      fallbackProviders: undefined,\n    };\n\n    // configure the ethereum plugin\n    const ethereumConfig: EthereumPluginConfigs = {\n      networks: {\n        testnet: {\n          provider: ethereum, // Ganache test network\n        },\n        mainnet: {\n          provider: \"http://localhost:8546\", // Ganache Ethereum mainnet fork\n        },\n      },\n      defaultNetwork: \"testnet\",\n    };\n\n    // configure the ens plugin\n    const ensConfig: EnsPluginConfigs = {\n      query: {\n        addresses: {\n          testnet: ensAddress,\n        },\n      },\n    };\n\n    // configure the client\n    const clientConfig: Partial<ClientConfig> = {\n      plugins: [\n        {\n          uri: \"w3://ens/ipfs.web3api.eth\",\n          plugin: ipfsPlugin(ipfsConfig),\n        },\n        {\n          uri: \"w3://ens/ens.web3api.eth\",\n          plugin: ensPlugin(ensConfig),\n        },\n        {\n          uri: \"w3://ens/ethereum.web3api.eth\",\n          plugin: ethereumPlugin(ethereumConfig),\n        },\n      ],\n    };\n\n    // create client\n    client = new Web3ApiClient(clientConfig);\n\n    // deploy simple storage contract\n    const { data, error } = await client.invoke<string>({\n      uri: ensUri,\n      module: \"mutation\",\n      method: \"deployContract\",\n    });\n    if (error) throw error;\n    simpleStorageAddress = data as string;\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  // highlight-start\n  test(\"setIpfsData\", async () => {\n    // invoke setIpfs method\n    const { data, error } = await client.invoke<SetIpfsDataResult>({\n      uri: ensUri,\n      module: \"mutation\",\n      method: \"setIpfsData\",\n      input: {\n        options: {\n          address: simpleStorageAddress,\n          data: \"Hello from IPFS!\",\n        },\n      }\n    });\n\n    // check for errors\n    expect(error).toBeFalsy(); // will be undefined if no exception is thrown in the wrapper\n    expect(data).toBeTruthy(); // will be undefined if an exception is thrown in the wrapper\n\n    // compare results\n    expect(data?.ipfsHash).toEqual(\"QmPhAJz5QbidN3LgT2eDiu6Z3nCFs2gYQMbjgEAncrGsis\");\n  });\n  // highlight-end\n});",
  "js-e2e-test-config-ethereum-import": "import { ethereumPlugin, EthereumPluginConfigs } from \"@web3api/ethereum-plugin-js\";",
  "js-e2e-test-config-ipfs-import": "import { ipfsPlugin, IpfsPluginConfigs } from \"@web3api/ipfs-plugin-js\";",
  "js-e2e-test-config-ens-import": "import { ensPlugin, EnsPluginConfigs } from \"@web3api/ens-plugin-js\";",
  "js-e2e-test-config-ipfs": "const ipfsConfig: IpfsPluginConfigs = {\n  provider: ipfs,\n  fallbackProviders: undefined,\n};",
  "js-e2e-test-config-ethereum": "const ethereumConfig: EthereumPluginConfigs = {\n  networks: {\n    testnet: {\n      provider: ethereum, // Ganache test network\n    },\n    mainnet: {\n      provider: \"http://localhost:8546\", // Ganache Ethereum mainnet fork\n    },\n  },\n  defaultNetwork: \"testnet\",\n};",
  "js-e2e-test-config-ens": "const ensConfig: EnsPluginConfigs = {\n  query: {\n    addresses: {\n      testnet: ensAddress,\n    },\n  },\n};",
  "js-e2e-test-init": "import { initTestEnvironment, stopTestEnvironment } from \"@web3api/test-env-js\";\n\njest.setTimeout(120000);\n\ndescribe('Wrapper Test', () => {\n\n  beforeAll(async () => {\n    // initialize test environment\n    const { ipfs, ethereum, ensAddress, registrarAddress, resolverAddress } = await initTestEnvironment();\n  });\n\n  afterAll(async () => {\n    // stop test environment\n    await stopTestEnvironment();\n  });\n\n  test(\"\", async () => { });\n});",
  "js-e2e-test-types": "export type String = string;\nexport type Boolean = boolean;\n\nexport interface SetIpfsDataOptions {\n  address: Types.String;\n  data: Types.String;\n}\n\nexport interface SetIpfsDataResult {\n  ipfsHash: Types.String;\n  txReceipt: Types.String;\n}\n\n/// Imported Objects START ///\n\n/* URI: \"w3://ens/ethereum.web3api.eth\" */\nexport interface Ethereum_Connection {\n  node?: Types.String | null;\n  networkNameOrChainId?: Types.String | null;\n}",
  "yaml-e2e-test-app-manifest": "format: 0.0.1-prealpha.1\nlanguage: app/typescript\nschema: ../../../build/schema.graphql",
  "as-simple-storage-mutation-import": "import {\n  Ethereum_Mutation,\n  Ipfs_Mutation,\n  Input_setData,\n  Input_setIpfsData,\n  SetIpfsDataResult,\n} from \"./w3\";",
  "as-simple-storage-mutation": "export function setIpfsData(input: Input_setIpfsData): SetIpfsDataResult {\n  // 1. Upload the data to IPFS\n  const ipfsHash = Ipfs_Mutation.addFile({\n    data: String.UTF8.encode(input.options.data),\n  }).unwrap();\n\n  // 2. Add the data's IPFS hash to SimpleStorage using `setHash(...)`\n  const txReceipt = Ethereum_Mutation.callContractMethodAndWait({\n    address: input.options.address,\n    method: 'function setHash(string value)',\n    args: [ipfsHash],\n    connection: input.connection\n  }).unwrap();\n\n  // 3. Return the result\n  return {\n    ipfsHash,\n    txReceipt: txReceipt.transactionHash,\n  };\n}",
  "gql-simple-storage-mutation-schema-ipfs-import": "#import { Mutation } into Ipfs from \"w3://ens/ipfs.web3api.eth\"",
  "gql-simple-storage-mutation-schema": "type Mutation {\n  setData(\n    address: String!\n    value: UInt32!\n    connection: Ethereum_Connection\n  ): String!\n\n  deployContract(\n    connection: Ethereum_Connection\n  ): String!\n\n# highlight-start\n  setIpfsData(\n    options: SetIpfsDataOptions!\n    connection: Ethereum_Connection\n  ): SetIpfsDataResult!\n}\n\ntype SetIpfsDataOptions {\n  address: String!\n  data: String!\n}\n\ntype SetIpfsDataResult {\n  ipfsHash: String!\n  txReceipt: String!\n}\n# highlight-end",
  "as-simple-storage-query": "// highlight-start\nimport {\n  Ethereum_Query,\n  Ipfs_Query,\n  Input_getData,\n  Input_getIpfsData\n} from './w3';\n// highlight-end\n\nexport function getData(input: Input_getData): u32 {\n  const res = Ethereum_Query.callContractView({\n    address: input.address,\n    method: \"function get() view returns (uint256)\",\n    args: null,\n    connection: input.connection\n  }).unwrap();\n\n  return U32.parseInt(res);\n}\n\n// highlight-start\nexport function getIpfsData(input: Input_getIpfsData): string {\n  const hash = Ethereum_Query.callContractView({\n    address: input.address,\n    method: 'function getHash() view returns (string)',\n    args: null,\n    connection: input.connection\n  }).unwrap();\n\n  return String.UTF8.decode(\n    Ipfs_Query.catFile({ cid: hash }).unwrap()\n  );\n}\n// highlight-end",
  "gql-simple-storage-query-schema": "#import { Query, Connection } into Ethereum from \"w3://ens/ethereum.web3api.eth\"\n# highlight-start\n#import { Query } into Ipfs from \"w3://ens/ipfs.web3api.eth\"\n# highlight-end\n\ntype Query {\n  getData(\n    address: String!\n    connection: Ethereum_Connection\n  ): Int!\n\n  # highlight-start\n  getIpfsData(\n    address: String!\n    connection: Ethereum_Connection\n  ): String!\n  # highlight-end\n}",
  "cli-command-help-": "w3 version 0.0.1-prealpha.77\n\n  w3             ðŸ”¥ Web3API CLI ðŸ”¥                       \n  help (h)       -                                     \n  test-env (t)   Manage a test environment for Web3API \n  query (q)      Query Web3APIs using recipe scripts   \n  plugin (p)     Build/generate types for the plugin   \n  deploy (b)     Deploys/Publishes a Web3API           \n  create (c)     Create a new project with w3 CLI      \n  codegen (g)    Auto-generate API Types               \n  build (b)      Builds a Web3API                      \n  app (a)        Build/generate types for your app",
  "cli-command-help-app": "w3 app command [options]\n\nCommands:\n  codegen   Generate code for the app\n\nOptions:\n  -h, --help                              Show usage information\n  -m, --manifest-file <path>              Path to the Web3API App manifest file (default: web3api.app.yaml | web3api.app.yml)\n  -c, --codegen-dir <path>                 Output directory for the generated code (default: ./src/w3)\n  -i, --ipfs [<node>]                     IPFS node to load external schemas (default: ipfs.io & localhost)\n  -e, --ens [<address>]                   ENS address to lookup external schemas (default: 0x0000...2e1e)",
  "cli-command-help-build": "w3 build [options]\n\nOptions:\n  -h, --help                         Show usage information\n  -m, --manifest-file <path>         Path to the Web3API Build manifest file (default: web3api.yaml | web3api.yml)\n  -o, --output-dir <path>            Output directory for build results (default: build/)\n  -w, --watch                        Automatically rebuild when changes are made (default: false)\n  -v, --verbose                      Verbose output (default: false)",
  "cli-command-help-codegen": "w3 codegen [options]\n\nOptions:\n  -h, --help                              Show usage information\n  -m, --manifest-file <path>              Path to the Web3API manifest file (default: web3api.yaml | web3api.yml)\n  -c, --codegen-dir <path>                Output directory for the generated code (default: ./w3)\n  -s, --script <path>                     Path to a custom generation script (JavaScript | TypeScript)\n  -i, --ipfs [<node>]                     IPFS node to load external schemas (default: ipfs.io & localhost)\n  -e, --ens [<address>]                   ENS address to lookup external schemas (default: 0x0000...2e1e)",
  "cli-command-help-create": "w3 create command <project-name> [options]\n\nCommands:\n  api <lang>     Create a Web3API project\n    langs: assemblyscript, interface\n  app <lang>     Create a Web3API application\n    langs: typescript-node, typescript-react\n  plugin <lang>  Create a Web3API plugin\n    langs: typescript\n\nOptions:\n  -h, --help               Show usage information\n  -o, --output-dir <path>  Output directory for the new project",
  "cli-command-help-deploy": "w3 deploy [options]\n\nOptions:\n  -h, --help                         Show usage information\n  -m, --manifest-file <path>         Path to the Web3API Deploy manifest file (default: web3api.yaml | web3api.yml)\n  -v, --verbose                      Verbose output (default: false)",
  "cli-command-help-plugin": "w3 plugin command [options]\n\nCommands:\n  codegen   Generate code for the plugin\n\nOptions:\n  -h, --help                       Show usage information\n  -m, --manifest-file <path>       Path to the Web3API Plugin manifest file (default: web3api.plugin.yaml | web3api.plugin.yml)\n  -p, --publish-dir <path>  Output path for the built schema and manifest (default: ./build)\n  -c, --codegen-dir <path>    Output directory for the generated types (default: ./src/w3)\n  -i, --ipfs [<node>]              IPFS node to load external schemas (default: dev-server's node)\n  -e, --ens [<address>]            ENS address to lookup external schemas (default: 0x0000...2e1e)",
  "cli-command-help-query": "w3 query [options] <recipe-script>\n\nOptions:\n  -h, --help                         Show usage information\n  -t, --test-ens                     Use the development server's ENS instance\n  -c, --client-config <config-path>  Add custom configuration to the Web3ApiClient\n  -o, --output-file                  Output file path for the query result\n  -q, --quiet                        Suppress output",
  "cli-command-help-test-env": "w3 test-env command\n\nCommands:\n  up    Startup the test env\n  down  Shutdown the test env\n\nOptions:\n  -h, --help          Show usage information",
  "js-create-client-instance": "import { Web3ApiClient } from \"@web3api/client-js\";\n\nconst client = new Web3ApiClient();",
  "js-client-hello-world": "client.invoke({\n  uri: \"ens/api.helloworld.web3api.eth\",\n  module: \"query\",\n  method: \"logMessage\",\n  input: {\n    message: \"Hello World!\"\n  }\n});",
  "js-react-provider": "import React from 'react';\nimport { Web3ApiProvider } from '@web3api/react';\n\nexport const App: React.FC = () => {\n  return (\n    <Web3ApiProvider>\n        <HelloWorld />\n    </Web3ApiProvider>\n  );\n};",
  "js-react-provider-empty-redirects": "<Web3ApiProvider redirects={ [] }/>",
  "js-react-custom-provider": "import { createWeb3ApiProvider } from '@web3api/react';\n\nconst CustomWeb3ApiProvider = createWeb3ApiProvider('custom');\n\nexport const CustomProvider = ({ children }: { children: JSX.Element }) => {\n  return (\n    <CustomWeb3ApiProvider>\n      {children}\n    </CustomWeb3ApiProvider>\n  );\n};",
  "js-react-useWeb3ApiQuery": "const { execute, data, errors, loading } = useWeb3ApiQuery({\n  uri: 'ens/api.helloworld.polywrap.eth',\n  query: `{\n    logMessage(message: \"Hello World!\")\n  }`,\n});",
  "js-react-useWeb3ApiQuery-custom-provider": "const { execute, data, errors, loading } = useWeb3ApiQuery({\n  provider: \"custom\",\n  uri: 'ens/api.helloworld.polywrap.eth',\n  query: `{\n    logMessage(message: \"Hello World!\")\n  }`,\n});",
  "js-react-useWeb3ApiInvoke": "const { execute, data, error, loading } = useWeb3ApiInvoke({\n  uri: 'ens/api.helloworld.polywrap.eth',\n  module: \"query\",\n  method: \"logMessage\",\n  input: {\n    message: \"Hello World!\",\n  },\n});",
  "js-react-useWeb3ApiClient": "const client = useWeb3ApiClient();"
}